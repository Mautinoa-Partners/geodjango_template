{
  "name": "pbf",
  "version": "1.3.5",
  "description": "a low-level, lightweight protocol buffers implementation in JavaScript",
  "main": "index.js",
  "scripts": {
    "test": "eslint index.js buffer.js test/*.js bin/pbf && tap test/*.test.js",
    "cov": "tap test/*.test.js --cov",
    "build-min": "mkdirp dist && browserify index.js -s Pbf | uglifyjs -c warnings=false -m > dist/pbf.js",
    "build-dev": "mkdirp dist && browserify index.js -d -s Pbf > dist/pbf-dev.js"
  },
  "bin": {
    "pbf": "bin/pbf"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:mapbox/pbf.git"
  },
  "keywords": [
    "protocol",
    "buffer",
    "pbf",
    "protobuf",
    "binary",
    "format",
    "serialization",
    "encoder",
    "decoder"
  ],
  "author": {
    "name": "Konstantin Kaefer"
  },
  "license": "BSD",
  "bugs": {
    "url": "https://github.com/mapbox/pbf/issues"
  },
  "homepage": "https://github.com/mapbox/pbf",
  "dependencies": {
    "ieee754": "^1.1.6",
    "resolve-protobuf-schema": "^2.0.0"
  },
  "devDependencies": {
    "benchmark": "^1.0.0",
    "browserify": "^11.2.0",
    "eslint": "^1.6.0",
    "eslint-config-mourner": "^1.0.1",
    "mkdirp": "^0.5.1",
    "protocol-buffers": "^3.1.3",
    "tap": "^2.0.0",
    "uglify-js": "^2.4.24"
  },
  "eslintConfig": {
    "extends": "mourner",
    "rules": {
      "space-before-function-paren": [
        2,
        "never"
      ],
      "key-spacing": 0,
      "no-empty": 0
    }
  },
  "readme": "# pbf\n\n[![build status](https://secure.travis-ci.org/mapbox/pbf.png)](http://travis-ci.org/mapbox/pbf) [![Coverage Status](https://coveralls.io/repos/mapbox/pbf/badge.png)](https://coveralls.io/r/mapbox/pbf)\n\nA low-level, fast, ultra-lightweight (3KB gzipped) JavaScript library for decoding and encoding [protocol buffers](https://developers.google.com/protocol-buffers) (a compact binary format for structured data serialization).\n\nDesigned to be a building block for writing customized decoders and encoders.\nIf you need an all-purpose protobuf JS library that does most of the work for you,\ntake a look at [protocol-buffers](https://github.com/mafintosh/protocol-buffers) too.\n\n## Examples\n\n#### Using Compiled Code\n\nInstall `pbf` and compile a JavaScript module from a `.proto` file:\n\n```bash\n$ npm install -g pbf\n$ pbf test.proto > test.js\n```\n\nThen read and write objects using the module like this:\n\n```js\nvar obj = Test.read(new Pbf(buffer)); // read\nvar buffer = Test.write(obj, new Pbf()); // write\n```\n\n#### Custom Reading\n\n```js\nvar data = new Pbf(buffer).readFields(readData, {});\n\nfunction readData(tag, data, pbf) {\n    if (tag === 1) data.name = pbf.readString();\n    else if (tag === 2) data.version = pbf.readVarint();\n    else if (tag === 3) data.layer = pbf.readMessage(readLayer, {});\n}\nfunction readLayer(tag, layer, pbf) {\n    if (tag === 1) layer.name = pbf.readString();\n    else if (tag === 3) layer.size = pbf.readVarint();\n}\n```\n\n#### Custom Writing\n\n```js\nvar pbf = new Pbf();\nwriteData(data, pbf);\nvar buffer = pbf.finish();\n\nfunction writeData(data, pbf) {\n    pbf.writeStringField(1, data.name);\n    pbf.writeVarintField(2, data.version);\n    pbf.writeMessage(3, writeLayer, data.layer);\n}\nfunction writeLayer(layer, pbf) {\n    pbf.writeStringField(1, layer.name);\n    pbf.writeVarintField(2, layer.size);\n}\n```\n\n\n## Install\n\nNode and Browserify:\n\n```bash\nnpm install pbf\n```\n\nMaking a browser build:\n\n```bash\nnpm install\nnpm run build-dev # dist/pbf-dev.js (development build)\nnpm run build-min # dist/pbf.js (minified production build)\n```\n\n## API\n\nCreate a `Pbf` object, optionally given a `Buffer` or `Uint8Array` as input data:\n\n```js\n// parse a pbf file from disk in Node\nvar pbf = new Pbf(fs.readFileSync('data.pbf'));\n\n// parse a pbf file in a browser after an ajax request with responseType=\"arraybuffer\"\nvar pbf = new Pbf(new Uint8Array(xhr.response));\n```\n\n`Pbf` object properties:\n\n```js\npbf.length; // length of the underlying buffer\npbf.pos; // current offset for reading or writing\n```\n\n#### Reading\n\nRead a sequence of fields:\n\n```js\npbf.readFields(function (tag) {\n    if (tag === 1) pbf.readVarint();\n    else if (tag === 2) pbf.readString();\n    else ...\n});\n```\n\nIt optionally accepts an object that will be passed to the reading function for easier construction of decoded data,\nand also passes the `Pbf` object as a third argument:\n\n```js\nvar result = pbf.readFields(callback, {})\n\nfunction callback(tag, result, pbf) {\n    if (tag === 1) result.id = pbf.readVarint();\n}\n```\n\nTo read an embedded message, use `pbf.readMessage(fn[, obj])` (in the same way as `read`).\n\nRead values:\n\n```js\nvar value = pbf.readVarint();\nvar str = pbf.readString();\nvar numbers = pbf.readPackedVarint();\n```\n\nFor lazy or partial decoding, simply save the position instead of reading a value,\nthen later set it back to the saved value and read:\n\n```js\nvar fooPos = -1;\npbf.readFields(function (tag) {\n    if (tag === 1) fooPos = pbf.pos;\n});\n...\npbf.pos = fooPos;\npbf.readMessage(readFoo);\n```\n\nScalar reading methods:\n\n* `readVarint()`\n* `readSVarint()`\n* `readVarint64()` (`readVarint` version that handles negative `int64` values)\n* `readFixed32()`\n* `readFixed64()`\n* `readSFixed32()`\n* `readSFixed64()`\n* `readBoolean()`\n* `readFloat()`\n* `readDouble()`\n* `readString()`\n* `readBytes()`\n* `skip(value)`\n\nPacked reading methods:\n\n* `readPackedVarint()`\n* `readPackedSVarint()`\n* `readPackedFixed32()`\n* `readPackedFixed64()`\n* `readPackedSFixed32()`\n* `readPackedSFixed64()`\n* `readPackedBoolean()`\n* `readPackedFloat()`\n* `readPackedDouble()`\n\n#### Writing\n\nWrite values:\n\n```js\npbf.writeVarint(123);\npbf.writeString(\"Hello world\");\n```\n\nWrite an embedded message:\n\n```js\npbf.writeMessage(1, writeObj, obj);\n\nfunction writeObj(obj, pbf) {\n    pbf.writeStringField(obj.name);\n    pbf.writeVarintField(obj.version);\n}\n```\n\nField writing methods:\n\n* `writeVarintField(tag, val)`\n* `writeSVarintField(tag, val)`\n* `writeFixed32Field(tag, val)`\n* `writeFixed64Field(tag, val)`\n* `writeSFixed32Field(tag, val)`\n* `writeSFixed64Field(tag, val)`\n* `writeBooleanField(tag, val)`\n* `writeFloatField(tag, val)`\n* `writeDoubleField(tag, val)`\n* `writeStringField(tag, val)`\n* `writeBytesField(tag, buffer)`\n\nPacked field writing methods:\n\n* `writePackedVarint(tag, val)`\n* `writePackedSVarint(tag, val)`\n* `writePackedSFixed32(tag, val)`\n* `writePackedSFixed64(tag, val)`\n* `writePackedBoolean(tag, val)`\n* `writePackedFloat(tag, val)`\n* `writePackedDouble(tag, val)`\n\nScalar writing methods:\n\n* `writeVarint(val)`\n* `writeSVarint(val)`\n* `writeSFixed32(val)`\n* `writeSFixed64(val)`\n* `writeBoolean(val)`\n* `writeFloat(val)`\n* `writeDouble(val)`\n* `writeString(val)`\n* `writeBytes(buffer)`\n\nMessage writing methods:\n\n* `writeMessage(tag, fn[, obj])`\n* `writeRawMessage(fn[, obj])`\n\nMisc methods:\n\n* `realloc(minBytes)` - pad the underlying buffer size to accommodate the given number of bytes;\n   note that the size increases exponentially, so it won't necessarily equal the size of data written\n* `finish()` - make the current buffer ready for reading and return the data as a buffer slice\n* `destroy()` - dispose the buffer\n\nFor an example of a real-world usage of the library, see [vector-tile-js](https://github.com/mapbox/vector-tile-js).\n\n\n## Proto Schema to JavaScript\n\nIf installed globally, `pbf` provides a binary that compiles `proto` files into JavaScript modules. Usage:\n\n```bash\n$ pbf <proto_path> [--no-write] [--no-read] [--browser]\n```\n\nThe `--no-write` and `--no-read` switches remove corresponding code in the output.\nThe `--browser` switch makes the module work in browsers instead of Node.\n\nThe resulting module exports each message by name with the following methods:\n\n* `read(pbf)` - decodes an object from the given `Pbf` instance\n* `write(obj, pbf)` - encodes an object into the given `Pbf` instance (usually empty)\n\nThe resulting code is pretty short and easy to understand, so you can customize it easily.\n\n\n## Changelog\n\n#### 1.3.5 (Oct 5, 2015)\n\n- Added support for `syntax` keyword proto files (by updating `resolve-protobuf-schema` dependency).\n\n#### 1.3.4 (Jul 31, 2015)\n\n- Added `writeRawMessage` method for writing a message without a tag, useful for creating pbfs with multiple top-level messages.\n\n#### 1.3.2 (Mar 5, 2015)\n\n- Added `readVarint64` method for proper decoding of negative `int64`-encoded values.\n\n#### 1.3.1 (Feb 20, 2015)\n\n- Fixed pbf proto compile tool generating broken writing code.\n\n#### 1.3.0 (Feb 5, 2015)\n\n- Added `pbf` binary that compiles `.proto` files into `Pbf`-based JavaScript modules.\n\n#### 1.2.0 (Jan 5, 2015)\n\n##### Breaking API changes\n\n- Changed `writeMessage` signature to `(tag, fn, obj)` (see example in the docs)\n  for a huge encoding performance improvement.\n- Replaced `readPacked` and `writePacked` methods that accept type as a string\n  with `readPackedVarint`, etc. for each type (better performance and simpler API).\n\n##### Improvements\n\n- 5x faster encoding in Node (vector tile benchmark).\n- 40x faster encoding and 3x faster decoding in the browser (vector tile benchmark).\n\n#### 1.1.4 (Jan 2, 2015)\n\n- Significantly improved `readPacked` and `writePacked` performance (the tile reading benchmark is now 70% faster).\n\n#### 1.1.3 (Dec 26, 2014)\n\nBrings tons of improvements and fixes over the previous version (`0.0.2`).\nBasically makes the library complete.\n\n##### Improvements\n\n- Improved performance of both reading and writing.\n- Made the browser build 3 times smaller.\n- Added convenience `readFields` and `readMessage` methods for a much easier reading API.\n- Added reading methods: `readFloat`, `readBoolean`, `readSFixed32`, `readSFixed64`.\n- Added writing methods: `writeUInt64`, `writeSFixed32`, `writeSFixed64`.\n- Improved `readDouble` and `readString` to use native Buffer methods under Node.\n- Improved `readString` and `writeString` to use HTML5 `TextEncoder` and `TextDecoder` where available.\n- Made `Pbf` `buffer` argument optional.\n- Added extensive docs and examples in the readme.\n- Added an extensive test suite that brings test coverage up to 100%.\n\n##### Breaking API changes\n\n- Renamed `readBuffer`/`writeBuffer` to `readBytes`/`writeBytes`.\n- Renamed `readUInt32`/`writeUInt32` to `readFixed32`/`writeFixed32`, etc.\n- Renamed `writeTaggedVarint` to `writeVarintField`, etc.\n- Changed `writePacked` signature from `(type, tag, items)` to `(tag, type, items)`.\n\n##### Bugfixes\n\n- Fixed `readVarint` to handle varints bigger than 6 bytes.\n- Fixed `readSVarint` to handle number bigger than `2^30`.\n- Fixed `writeVarint` failing on some integers.\n- Fixed `writeVarint` not throwing an error on numbers that are too big.\n- Fixed `readUInt64` always failing.\n- Fixed writing to an empty buffer always failing.\n",
  "readmeFilename": "README.md",
  "_id": "pbf@1.3.5",
  "dist": {
    "shasum": "6e9073d2a13d978c4405ce69ab60a0fd2db54cfa"
  },
  "_from": "pbf@1.3.5",
  "_resolved": "https://registry.npmjs.org/pbf/-/pbf-1.3.5.tgz"
}
